---
description: 前端 Pages 文件夹编码规范 - 页面与子组件
globs:
  - '**/src/pages/**/*.ts'
  - '**/src/pages/**/*.tsx'
alwaysApply: false
---

# Pages 编码规范

本规则说明如何组织与编写 **pages/** 下的代码，适用于任意 React 前端项目的页面层。

## 文件组织

```
pages/
├── index.ts
├── <PageName>Page/
│   ├── index.tsx          # 页面入口
│   ├── styles.module.css
│   ├── components/       # 仅本页使用的组件
│   │   ├── index.ts
│   │   └── ...
│   └── schemas/           # 可选：表单校验（如 Zod）
│       └── ...
└── ...
```

- 每页一个文件夹，以 `Page` 结尾便于识别
- 页面专属组件放在该页下的 `components/`，不放入全局 `src/components`

## 一页一 JSON（i18n）

- **每个页面有且仅有一个 i18n 命名空间**，对应 `assets/languages/<lang>/<PageName>.json`（如 `PermissionManagementPage.json`）。
- 在 **i18nResources.ts** 中为该页面注册该命名空间（`RESOURCES` 与 `NAME_SPACES_MAP`），并在各语言下导入对应的 JSON。
- 页面入口及该页下所有子组件统一使用 **同一命名空间**：`useTranslation("<PageName>")`（如 `useTranslation("PermissionManagementPage")`），不在子组件里混用其他页面命名空间。
- 不把多个页面的文案塞进一个 JSON；不把一个页面的文案拆到多个 JSON。一页一 JSON，便于维护和按页翻译。

## 页面组件结构

### 基础展示页

```tsx
const ListPage = memo(() => {
  const { t } = useTranslation("ListPage");
  const currentUserId = useAuthStore((s) => s.currentUserId); // 若需鉴权

  if (!currentUserId) {
    return <div className={styles.error}><p>{t("notFound")}</p></div>;
  }

  return (
    <div className={styles.container}>
      <h1 className={styles.title}>{t("title")}</h1>
      <Suspense loadingType="ecg" loadingText={t("loading")}>
        <ListContent userId={currentUserId} />
      </Suspense>
    </div>
  );
});
ListPage.displayName = "ListPage";
export default ListPage;
```

- 用 `memo` 包裹，设置 `displayName`
- 异步内容用 `Suspense` 包裹，loading 样式与项目统一
- 鉴权、权限不足等提前 return，避免子组件依赖 undefined

### 表单页

```tsx
const EditItemPage = memo(() => {
  const navigate = useNavigate();
  const { id } = useParams();
  if (!id) {
    navigate(ROUTES.LIST);
    return null;
  }

  return (
    <div className={styles.container}>
      <header>
        <Button variant="ghost" leftIcon={<ArrowLeft />} onClick={() => navigate(ROUTES.LIST)}>
          {t("back")}
        </Button>
        <h1>{t("title")}</h1>
      </header>
      <Suspense loadingType="ecg" loadingText={t("loading")}>
        <EditItemForm itemId={id} />
      </Suspense>
    </div>
  );
});
```

- 表单内容放在子组件（如 `EditItemForm`），内部使用 `FormProvider` + `react-hook-form`
- 提交：`form.handleSubmit(onSubmit, onSubmitError)`；取消/返回用 `navigate` 或路由工具

### 逻辑归属（谁用谁管）

- **只被一个子组件用到的逻辑**（例如某列表的删除、设主、排序保存）：  
  把相关 hooks 和 handler 写在该子组件内部，父组件只传 **数据**（如 `userId`、列表数据），不传一堆 `onDelete`、`onSetPrimary` 等回调。
- **多个子组件共用或由父组件协调的状态**（例如上传区 + 确认区 + 当前上传 ID）：  
  状态和 handler 保留在父组件，通过 props 传给子组件。
- 这样页面入口只负责布局、鉴权、路由，具体业务收敛在对应子组件或表单子组件中。

## 命名规范

- 文件夹：PascalCase，`<Name>Page/`
- 入口文件：`index.tsx`
- 样式：`styles.module.css`
- 子组件：PascalCase，与业务含义一致（如 `ListContent`、`EditItemForm`）

## 数据获取与错误

- 在页面或子组件内用自定义 hooks（如 `useUser`、`useItemsByUserId`）获取数据
- 错误状态在页面层处理（无权限、无数据、加载失败），子组件可接收 `error` 或 `isEmpty` 等 props 做展示
- 需要「当前用户」时从 auth store 或 context 取，不要在多处重复请求「当前用户」

## 实现建议

- 页面尽量薄：只做布局、鉴权、路由和 Suspense 包裹；复杂表单或列表逻辑放在该页的 `components/` 或子组件中
- 保持每页一个目录，样式、子组件、schemas 都收在该目录下，便于按页面维护
