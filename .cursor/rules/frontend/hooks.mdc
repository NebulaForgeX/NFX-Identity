---
description: 前端 Hooks 文件夹编码规范 - 数据查询与 Mutation
globs:
  - '**/src/hooks/**/*.ts'
  - '**/src/hooks/**/*.tsx'
alwaysApply: false
---

# Hooks 编码规范

本规则说明如何组织与编写 **hooks/** 下的代码，适用于使用 React Query（或类似） + 事件驱动缓存失效的前端项目。

## 文件组织

```
hooks/
├── core/              # 可选：统一 query 工厂、类型
│   ├── makeUnifiedQuery.ts
│   ├── makeUnifiedInfiniteQuery.ts
│   └── type.ts
├── use<Feature>.ts    # 按功能模块（如 useAuth.ts、useUser.ts）
└── index.ts           # 统一导出
```

## 查询类 Hooks

### 使用统一 Query 工厂（若项目有）

```typescript
import { makeUnifiedQuery } from "@/hooks/core/makeUnifiedQuery";
import { GetUser } from "@/apis/user.api";
import { USER_QUERY_KEYS } from "@/constants";

export const useUser = (params: UnifiedQueryParams<User> & { id: string }) => {
  const { id, options, postProcess } = params;
  const makeQuery = makeUnifiedQuery(
    async (p: { id: string }) => await GetUser(p.id),
    "suspense", // 或 "normal" 以支持 enabled
    postProcess
  );
  return makeQuery(USER_QUERY_KEYS.item(id), { id }, options);
};

export const useUsersByOrgId = (params: UnifiedQueryParams<User[]> & { orgId: string }) => {
  const { orgId, options, postProcess } = params;
  const makeQuery = makeUnifiedQuery(
    async (p: { orgId: string }) => await GetUsersByOrgId(p.orgId),
    "suspense",
    postProcess
  );
  return makeQuery(USER_QUERY_KEYS.list, { orgId }, options);
};
```

- Query Key 与项目中的 constants 保持一致（如按 entity 分 list/item）
- 需要 `enabled` 时用 `"normal"` 模式并传 `options`

### 无统一工厂时

- 直接用 `useQuery`，queryKey 集中定义在 constants 中，保持与缓存失效事件所用 key 一致

## Mutation 类 Hooks

### 标准模式

```typescript
import { useMutation } from "@tanstack/react-query";
import type { AxiosError } from "axios";
import { CreateUser } from "@/apis/user.api";
import { userEventEmitter, userEvents } from "@/events/user";
import { showError, showSuccess } from "@/stores/modalStore"; // 或项目中的提示方式

export const useCreateUser = () => {
  return useMutation({
    mutationFn: async (params: CreateUserRequest) => await CreateUser(params),
    onSuccess: (_, variables) => {
      userEventEmitter.emit(userEvents.INVALIDATE_USERS);
      userEventEmitter.emit(userEvents.INVALIDATE_USER, variables.orgId); // 按需
      showSuccess("创建成功");
    },
    onError: (error: AxiosError) => {
      showError("创建失败：" + (error.message || "请稍后重试"));
    },
  });
};

export const useUpdateUser = () => {
  return useMutation({
    mutationFn: async ({ id, data }: { id: string; data: UpdateUserRequest }) =>
      await UpdateUser(id, data),
    onSuccess: (_, variables) => {
      userEventEmitter.emit(userEvents.INVALIDATE_USERS);
      userEventEmitter.emit(userEvents.INVALIDATE_USER, variables.id);
      showSuccess("更新成功");
    },
    onError: (error: AxiosError) => {
      showError("更新失败：" + error.message);
    },
  });
};

export const useDeleteUser = () => {
  return useMutation({
    mutationFn: async (id: string) => await DeleteUser(id),
    onSuccess: (_, id) => {
      userEventEmitter.emit(userEvents.INVALIDATE_USERS);
      userEventEmitter.emit(userEvents.INVALIDATE_USER, id);
      showSuccess("删除成功");
    },
    onError: (error: AxiosError) => {
      showError("删除失败：" + error.message);
    },
  });
};
```

### 约定

- **onSuccess**：必须触发与当前变更相关的缓存失效事件（列表 + 单条视业务需要），再统一提示成功
- **onError**：统一提示失败，可根据 `AxiosError` 或后端错误码做分支提示（如「账户已锁定」）
- 不在这里做路由跳转；页面层在 `mutate` 的 callback 或 `onSuccess` 里跳转

## 命名规范

- 文件：camelCase，`use<Feature>.ts`（如 `useUser.ts`、`useAuth.ts`）
- 查询：`useEntity`、`useEntityByXxx`、`useEntitiesByXxx`
- Mutation：`useCreateEntity`、`useUpdateEntity`、`useDeleteEntity`、`useSetPrimaryXxx` 等
- 工具类：`makeUnifiedQuery`、`makeUnifiedInfiniteQuery` 等放在 `core/` 并统一导出

## 其他类型 Hooks

- **Context**：`useXxx` 内部 `useContext(XxxContext)`，未在 Provider 内时 throw Error
- **计时/轮询**：用 `useState` + `useEffect` 或项目现有 store，保持单一数据源
- **表单/同步**：若与后端同步（如主题、偏好），在 hook 内调用 API 或 mutation，避免在组件里散落逻辑

## 实现建议

- 按功能模块拆分文件，避免单文件过大
- 所有 hooks 通过 `index.ts` 导出，便于页面和组件从 `@/hooks` 引用
- 缓存失效事件名与 Query Key 前缀要与 events、constants 中定义一致
