---
description: åç«¯ Go Modules Server ç¼–ç è§„èŒƒ - æœåŠ¡å™¨è£…é…ä¸ä¾èµ–æ³¨å…¥
globs:
  - '**/modules/**/server/**/*.go'
alwaysApply: false
---

# Modules Server ç¼–ç è§„èŒƒ

æœ¬è§„åˆ™è¯´æ˜å¦‚ä½•ç»„ç»‡ä¸ç¼–å†™ **modules/<module>/server/** ä¸‹çš„ä»£ç ï¼Œé€‚ç”¨äºæŒ‰æ¨¡å—æ‹†æœåŠ¡çš„ Go åç«¯é¡¹ç›®ã€‚server è´Ÿè´£ä¾èµ–è£…é…ï¼ˆwiringï¼‰ã€HTTP/gRPC/äº‹ä»¶æœåŠ¡å™¨å¯åŠ¨ä¸ä¼˜é›…å…³é—­ï¼Œä¸åŒ…å«ä¸šåŠ¡é€»è¾‘ã€‚

## æ–‡ä»¶ç»„ç»‡

```
modules/<module>/
â””â”€â”€ server/
    â”œâ”€â”€ server.go           # æœåŠ¡å™¨åˆå§‹åŒ–ï¼ˆHTTP/gRPC/Pipelineï¼‰
    â””â”€â”€ wiring.go           # ä¾èµ–æ³¨å…¥ï¼ˆDI å®¹å™¨ï¼‰
```

**ç¤ºä¾‹**ï¼š
- `server/server.go` - æœåŠ¡å™¨å¯åŠ¨é€»è¾‘
- `server/wiring.go` - ä¾èµ–æ³¨å…¥å’Œè£…é…é€»è¾‘
- æ¯ä¸ªæ¨¡å—æœ‰ç‹¬ç«‹çš„æœåŠ¡å™¨ç›®å½•

## Serverï¼ˆæœåŠ¡å™¨ï¼‰

```go
// âœ… GOOD - æœåŠ¡å™¨æ ‡å‡†ç»“æ„
package server

import (
    "context"
    "errors"
    "net"
    "net/http"
    "strconv"
    "<project>/modules/<module>/config"
    httpInterfaces "<project>/modules/<module>/interfaces/http"
    grpcInterfaces "<project>/modules/<module>/interfaces/grpc"
    eventbusInterfaces "<project>/modules/<module>/interfaces/pipeline"
    "<project>/pkgs/logx"
    "golang.org/x/sync/errgroup"
    "google.golang.org/grpc"
)

// RunHTTP è¿è¡Œ HTTP æœåŠ¡å™¨
func RunHTTP(ctx context.Context, cfg *config.Config) error {
    deps, err := NewDeps(ctx, cfg)
    if err != nil {
        return err
    }
    defer deps.Cleanup()

    httpSrv := httpInterfaces.NewHTTPServer(deps)
    httpAddr := net.JoinHostPort(cfg.Server.Host, strconv.Itoa(cfg.Server.HTTPPort))

    logx.S().Infof("âœ… HTTP server listening on %s", httpAddr)
    if err := httpSrv.Listen(httpAddr); err != nil && !errors.Is(err, http.ErrServerClosed) {
        return err
    }

    return nil
}

// RunGRPC è¿è¡Œ gRPC æœåŠ¡å™¨
func RunGRPC(ctx context.Context, cfg *config.Config) error {
    deps, err := NewDeps(ctx, cfg)
    if err != nil {
        return err
    }
    defer deps.Cleanup()

    grpcSrv := grpcInterfaces.NewServer(deps)
    grpcAddr := net.JoinHostPort(cfg.Server.Host, strconv.Itoa(cfg.Server.GRPCPort))

    grpcLis, err := net.Listen("tcp", grpcAddr)
    if err != nil {
        return err
    }
    defer grpcLis.Close()

    logx.S().Infof("âœ… gRPC server listening on %s", grpcAddr)
    if err := grpcSrv.Serve(grpcLis); err != nil && !errors.Is(err, grpc.ErrServerStopped) {
        return err
    }

    return nil
}

// RunPipeline è¿è¡Œ Pipeline æœåŠ¡å™¨ï¼ˆKafka äº‹ä»¶æ¶ˆè´¹è€…ï¼‰
func RunPipeline(ctx context.Context, cfg *config.Config) error {
    deps, err := NewDeps(ctx, cfg)
    if err != nil {
        return err
    }
    defer deps.Cleanup()

    eventbusSrv, err := eventbusInterfaces.NewServer(deps)
    if err != nil {
        return err
    }

    logx.S().Infof("âœ… Eventbus (Kafka) server listening on %v", cfg.KafkaConfig.Brokers)
    return eventbusSrv.Run(ctx)
}

// RunServer è¿è¡Œæ‰€æœ‰æœåŠ¡ï¼ˆHTTP + gRPC + Pipeline + Messagingï¼‰
func RunServer(ctx context.Context, cfg *config.Config) error {
    deps, err := NewDeps(ctx, cfg)
    if err != nil {
        return err
    }
    defer deps.Cleanup()

    logx.S().Info("âœ… All-in-One Server: All dependencies initialized successfully")

    // åˆå§‹åŒ–æœåŠ¡å™¨
    httpSrv := httpInterfaces.NewHTTPServer(deps)
    grpcSrv := grpcInterfaces.NewServer(deps)
    eventbusSrv, err := eventbusInterfaces.NewServer(deps)
    if err != nil {
        return err
    }

    httpAddr := net.JoinHostPort(cfg.Server.Host, strconv.Itoa(cfg.Server.HTTPPort))
    grpcAddr := net.JoinHostPort(cfg.Server.Host, strconv.Itoa(cfg.Server.GRPCPort))

    grpcLis, err := net.Listen("tcp", grpcAddr)
    if err != nil {
        return err
    }
    defer grpcLis.Close()

    g, gctx := errgroup.WithContext(ctx)

    // HTTP Server
    g.Go(func() error {
        logx.S().Infof("âœ… HTTP server listening on %s", httpAddr)
        if err := httpSrv.Listen(httpAddr); err != nil && !errors.Is(err, http.ErrServerClosed) {
            return err
        }
        return nil
    })

    // gRPC Server
    g.Go(func() error {
        logx.S().Infof("âœ… gRPC server listening on %s", grpcAddr)
        if err := grpcSrv.Serve(grpcLis); err != nil && !errors.Is(err, grpc.ErrServerStopped) {
            return err
        }
        return nil
    })

    // Pipeline (Kafka Eventbus) Server
    g.Go(func() error {
        logx.S().Infof("âœ… Eventbus (Kafka) server listening on %v", cfg.KafkaConfig.Brokers)
        return eventbusSrv.Run(ctx)
    })

    // Graceful shutdown handler
    g.Go(func() error {
        <-gctx.Done()
        logx.S().Info("ğŸ›‘ Shutting down all services...")
        _ = httpSrv.Shutdown()
        grpcSrv.GracefulStop()
        _ = eventbusSrv.Close()
        return nil
    })

    return g.Wait()
}
```

## Wiringï¼ˆä¾èµ–æ³¨å…¥ï¼‰

```go
// âœ… GOOD - ä¾èµ–æ³¨å…¥æ ‡å‡†ç»“æ„
package server

import (
    "context"
    "<project>/modules/<module>/application/<entity>"
    "<project>/modules/<module>/config"
    "<entity>Repo "<project>/modules/<module>/infrastructure/repository/<entity>"
    "<project>/pkgs/cache"
    "<project>/pkgs/health"
    "<project>/pkgs/kafkax"
    "<project>/pkgs/kafkax/eventbus"
    "<project>/pkgs/postgresqlx"
    "<project>/pkgs/rabbitmqx"
    "gorm.io/gorm"
)

// Dependencies ä¾èµ–å®¹å™¨
type Dependencies struct {
    healthMgr    *health.Manager
    cache        *cache.Connection
    postgres     *postgresqlx.Connection
    kafkaConfig  *kafkax.Config
    busPublisher *eventbus.BusPublisher
    <entity>AppSvc *<entity>.Service
    // ... å…¶ä»–ä¾èµ–
}

// NewDeps åˆ›å»ºä¾èµ–å®¹å™¨
func NewDeps(ctx context.Context, cfg *config.Config) (*Dependencies, error) {
    // åˆå§‹åŒ–æ•°æ®åº“
    postgres, err := postgresqlx.NewConnection(ctx, cfg.PostgreSQL)
    if err != nil {
        return nil, err
    }

    // åˆå§‹åŒ–ç¼“å­˜
    cache, err := cache.NewConnection(ctx, cfg.Cache)
    if err != nil {
        return nil, err
    }

    // åˆå§‹åŒ– Kafka å‘å¸ƒå™¨
    kafkaPublisher, err := kafkax.NewPublisher(cfg.KafkaConfig)
    if err != nil {
        return nil, err
    }
    topicResolver := kafkax.NewTopicResolver(cfg.KafkaConfig)
    busPublisher := eventbus.NewBusPublisher(kafkaPublisher, topicResolver)

    // åˆå§‹åŒ–ä»“åº“
    <entity>Repo := <entity>Repo.NewRepo(postgres.DB())

    // åˆå§‹åŒ–åº”ç”¨æœåŠ¡
    <entity>AppSvc := <entity>.NewService(<entity>Repo)

    // åˆå§‹åŒ–å¥åº·æ£€æŸ¥ç®¡ç†å™¨
    healthMgr := health.NewManager()
    healthMgr.Register("postgresql", postgres)
    healthMgr.Register("cache", cache)

    return &Dependencies{
        healthMgr:    healthMgr,
        cache:        cache,
        postgres:     postgres,
        kafkaConfig:  &cfg.KafkaConfig,
        busPublisher: busPublisher,
        <entity>AppSvc: <entity>AppSvc,
    }, nil
}

// Cleanup æ¸…ç†èµ„æº
func (d *Dependencies) Cleanup() {
    if d.postgres != nil {
        _ = d.postgres.Close()
    }
    if d.cache != nil {
        _ = d.cache.Close()
    }
    if d.busPublisher != nil {
        _ = d.busPublisher.Close()
    }
}
```

## å‘½åè§„èŒƒ

- **åŒ…å**ï¼šä½¿ç”¨ `server`
- **ä¾èµ–å®¹å™¨**ï¼šä½¿ç”¨ `Dependencies` æ ¼å¼: `Dependencies`
- **åˆ›å»ºå‡½æ•°**ï¼šä½¿ç”¨ `NewDeps` æ ¼å¼: `NewDeps`
- **æ¸…ç†æ–¹æ³•**ï¼šä½¿ç”¨ `Cleanup` æ ¼å¼: `Cleanup`
- **è¿è¡Œå‡½æ•°**ï¼šä½¿ç”¨ `Run<Service>` æ ¼å¼: `RunHTTP`, `RunGRPC`, `RunPipeline`, `RunServer`

## å®ç°å»ºè®®

- **ä¾èµ–æ³¨å…¥**ï¼šä½¿ç”¨æ„é€ å‡½æ•°æ³¨å…¥æ‰€æœ‰ä¾èµ–
- **èµ„æºç®¡ç†**ï¼šåœ¨ `Cleanup` æ–¹æ³•ä¸­é‡Šæ”¾æ‰€æœ‰èµ„æº
- **é”™è¯¯å¤„ç†**ï¼šåˆå§‹åŒ–å¤±è´¥æ—¶è¿”å›é”™è¯¯ï¼Œä¸ç»§ç»­æ‰§è¡Œ
- **ä¼˜é›…å…³é—­**ï¼šä½¿ç”¨ `errgroup` å’Œä¿¡å·å¤„ç†å®ç°ä¼˜é›…å…³é—­
- **æ—¥å¿—è®°å½•**ï¼šè®°å½•æœåŠ¡å™¨å¯åŠ¨å’Œå…³é—­ä¿¡æ¯
- **å¥åº·æ£€æŸ¥**ï¼šæ³¨å†Œæ‰€æœ‰å…³é”®ä¾èµ–åˆ°å¥åº·æ£€æŸ¥ç®¡ç†å™¨
- **æœåŠ¡åˆ†ç¦»**ï¼šæ”¯æŒå•ç‹¬è¿è¡Œ HTTPã€gRPC æˆ– Pipeline æœåŠ¡
- **ç»„åˆæœåŠ¡**ï¼š`RunServer` åœ¨ goroutines ä¸­è¿è¡Œæ‰€æœ‰æœåŠ¡ï¼Œé€‚åˆå¼€å‘ç¯å¢ƒ
